import {
  $,
  QwikDragEvent,
  QwikFocusEvent,
  QwikMouseEvent,
  QwikSubmitEvent,
  component$,
  useOn,
  useOnDocument,
  useSignal,
  useStyles$,
  useVisibleTask$,
} from @builder.io/qwik

import style from ./style.styl?inline

export default component$ =>
  useStyles$(style)
  lists := useSignal([["a", "b", "c"], ["d", "e", "f"]])

  useVisibleTask$ ({ cleanup, track }) =>
    track(lists)
    listsEl := document.querySelector("div.lists") as HTMLElement
    placeholderEl := document.querySelector("ul.placeholder") as HTMLElement
    emptyImage := document.createElement("img")

    let activeItem: null | {
      el: HTMLElement
      offset: { x: number; y: number }
    }

    closest := (node: Node | HTMLElement, selector: string): HTMLElement | null ->
      if (node <? HTMLElement)
        node.closest(selector)
      else
        node.parentElement!.closest(selector)

    dragstart := (event: DragEvent) ->
      target .= event.target as HTMLElement | Node
      // Find the closest draggable element
      el := closest(target, "[draggable]")

      if el
        { clientX, clientY } := event
        event.dataTransfer?.setDragImage(emptyImage, 0, 0)

        rect := el.getBoundingClientRect()
        offset :=
          x: clientX - rect.left
          y: clientY - rect.top
        activeItem = { el, offset }

        window.requestAnimationFrame ->
          Object.assign placeholderEl.style,
            height: rect.height + "px"
            width: rect.width + "px"
            display: "block"

          el.classList.add "dragging"

          Object.assign el.style,
            top:  clientY - offset.y + "px"
            left: clientX - offset.x + "px"

      return

    dragover := (event: DragEvent) ->
      if activeItem
        event.preventDefault()
        { clientX, clientY, target } := event

        // NOTE: Dragging is much smoother when the style is updated in an animation frame.
        window.requestAnimationFrame ->
          if activeItem
            { el, offset } := activeItem
            Object.assign el.style,
              top:  clientY - offset.y + "px"
              left: clientX - offset.x + "px"

            if target
              targetEl := closest(target as HTMLElement, "div.lists")

              // targetEl is the container of all the lists
              if targetEl
                n := lists.value.length
                { left, width } := targetEl.getBoundingClientRect()
                x := Math.floor ( clientX - left ) * n / width

                listElements := targetEl.querySelectorAll(":scope > ul[draggable]:not(.dragging)")
                document.querySelector("div.debug")!.textContent = `${x}, ${listElements.length}`
                targetEl.insertBefore placeholderEl, listElements[x]


    dragend := (event: DragEvent) ->
      window.requestAnimationFrame ->
        if activeItem
          { el } := activeItem
          el.classList.remove "dragging"
          Object.assign el.style,
            top: ""
            left: ""

          placeholderEl.parentElement!.insertBefore el, placeholderEl

          activeItem = null
          placeholderEl.style.display = "none"

    // NOTE: Attaching dragover to document so we don't have dead spots based on which element we are over
    document.addEventListener "dragover", dragover
    document.addEventListener "dragend", dragend
    listsEl.addEventListener "dragstart", dragstart

    cleanup =>
      document.removeEventListener "dragover", dragover
      document.removeEventListener "dragend", dragend
      listsEl.removeEventListener "dragstart", dragstart

  , strategy: 'document-ready'

  <div .lists>
    {lists.value.map (list, i) =>
      onSubmit$ := $ (event: QwikSubmitEvent<HTMLFormElement>, form: HTMLFormElement) ->
        inputEl := form.querySelector("input") as HTMLInputElement
        listsValue := lists.value
        listsValue[i].push inputEl.value
        lists.value = listsValue.slice()
        inputEl.value = ""

      <ul draggable>
        <h2> Heyy {i}
        {list.map (item) =>
          <li draggable>
            <textarea value={item}>
        }
        <form .add preventdefault:submit {onSubmit$}>
          <input name=""/>
          <button >Add</button>
      <ul .placeholder>
    }
