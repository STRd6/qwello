import {
  $,
  QwikDragEvent,
  QwikFocusEvent,
  QwikMouseEvent,
  QwikSubmitEvent,
  component$,
  useOn,
  useOnDocument,
  useSignal,
  useStore,
  useStyles$,
  useTask$,
  useResource$,
  useVisibleTask$,
} from @builder.io/qwik

// Hack to set dirty state
declare global
  interface Window
    dirty: =>

import { isBrowser } from @builder.io/qwik/build

interface State
  lists: {
    name: string
    items: string[]
  }[]

export default component$ =>
  state := useStore<State> {
    lists: []
  }, deep: true

  useVisibleTask$ () =>
    if isBrowser
      lists := window.localStorage.getItem "lists"
      if lists
        state.lists = JSON.parse lists

  useVisibleTask$ ({ cleanup, track }) =>
    track(state.lists)
    listsEl := document.querySelector("div.lists") as HTMLElement
    placeholderEl := document.querySelector("ul.placeholder") as HTMLElement
    emptyImage := document.createElement("img")

    persist := ->
      console.log("saving lists", state.lists)
      window.localStorage.setItem "lists", JSON.stringify state.lists

    // TODO: If I move this outside of useVisibleTask$ and use a closure instead of window.dirty it breaks rollup
    let timeout: number | null
    window.dirty = ->
      return if timeout
      timeout = window.setTimeout ->
        timeout = null
        persist()
      , 500

    let activeItem: null | {
      el: HTMLElement
      offset: { x: number; y: number }
      startIndex: number
    }

    closest := (node: Node | HTMLElement, selector: string): HTMLElement | null ->
      if (node <? HTMLElement)
        node.closest(selector)
      else
        node.parentElement!.closest(selector)

    dragstart := (event: DragEvent) ->
      target .= event.target as HTMLElement | Node
      // Find the closest draggable element
      el := closest(target, "[draggable]")

      if el
        event.preventDefault()
        { clientX, clientY, dataTransfer } := event

        rect := el.getBoundingClientRect()
        offset :=
          x: clientX - rect.left
          y: clientY - rect.top
        startIndex := Array.prototype.indexOf.call el.parentElement!.querySelectorAll(":scope > [draggable]"), el
        activeItem = { el, offset, startIndex }

        window.requestAnimationFrame ->
          if document.activeElement
            (document.activeElement as HTMLElement).blur()

          Object.assign placeholderEl.style,
            height: rect.height + "px"
            width: rect.width + "px"
            display: "block"

          el.parentElement!.insertBefore placeholderEl, el
          el.classList.add "dragging"

          Object.assign el.style,
            top:  clientY - offset.y + "px"
            left: clientX - offset.x + "px"

      return

    pointermove := (event: PointerEvent) ->
      if activeItem
        event.preventDefault()
        { clientX, clientY, target } := event

        // NOTE: Dragging is much smoother when the style is updated in an animation frame.
        window.requestAnimationFrame ->
          if activeItem
            { el, offset } := activeItem
            Object.assign el.style,
              top:  clientY - offset.y + "px"
              left: clientX - offset.x + "px"

            if target
              targetEl := closest(target as HTMLElement, "div.lists")

              // targetEl is the container of all the lists
              if targetEl
                n := state.lists.length
                { left, width } := targetEl.getBoundingClientRect()
                x := Math.floor ( clientX - left ) * n / width

                listElements := targetEl.querySelectorAll(":scope > ul[draggable]:not(.dragging)")
                targetEl.insertBefore placeholderEl, listElements[x]


    pointerup := (event: PointerEvent) ->
      if activeItem
        const endIndex = Math.min state.lists.length-1, Array.prototype.indexOf.call placeholderEl.parentElement!.querySelectorAll(":scope > ul:not(.dragging)"), placeholderEl
        { startIndex, el } := activeItem

        if endIndex !== -1 and endIndex !== startIndex
          // use splice to move the item
          from := state.lists[startIndex]
          to := state.lists[endIndex]
          state.lists.splice endIndex, 0, state.lists.splice(startIndex, 1)[0]
          console.log "moved", startIndex, endIndex, from.name, to.name
          window.dirty?()

        el.classList.remove "dragging"
        Object.assign el.style,
          top: ""
          left: ""

        activeItem = null
        placeholderEl.style.display = "none"
        // Return placeholder to original position, otherwise qwik gets confused when pushing a new list
        placeholderEl.parentElement!.insertBefore placeholderEl, null

    // NOTE: Attaching dragover to document so we don't have dead spots based on which element we are over
    document.addEventListener "pointermove", pointermove
    document.addEventListener "pointerup", pointerup
    listsEl.addEventListener "dragstart", dragstart

    cleanup =>
      document.removeEventListener "pointermove", pointermove
      document.removeEventListener "pointerup", pointerup
      listsEl.removeEventListener "dragstart", dragstart

  , strategy: 'document-ready'

  removeList := $ (list: State["lists"][number]) =>
    const index = state.lists.indexOf list
    if index >= 0
      state.lists.splice index, 1
      window.dirty?()
    return

  <div .lists>
    {state.lists.map (list, i) =>
      onSubmit$ := $ (event: QwikSubmitEvent<HTMLFormElement>, form: HTMLFormElement) ->
        inputEl := form.querySelector("input") as HTMLInputElement
        list.items.push inputEl.value
        inputEl.value = ""
        window.dirty?()
        return

      <ul draggable>
        <div .close onClick$={$ => removeList list}> X
        <input value={list.name} onInput$={(_, el) =>
          list.name = el.value
          window.dirty?()
        }/>
        {list.items.map (item) =>
          <li>
            <textarea value={item}>
        }
        <form .add preventdefault:submit {onSubmit$}>
          <input name=""/>
          <button >Add</button>
    }
    <ul .placeholder>
  <button .new-list onClick$={$ =>
    state.lists.push
      name: "New List"
      items: []
    window.dirty?()
    return
  }> New List
